###################################################################
####this script is plotting results from ADMIXTURE#################
#it is using the Q files generated by admixture and a list of samples
#a table containing first column of sample names and second of population, third of latitude, fourth of longitude
#it plots the admixture results on a map###########################
###################################################################
#this was useful: https://owensgl.github.io/biol525D/Topic_8-9/plotting_structure.html
#this is the latest version of this script: 4 May 2025


library(ggplot2)
library(tidyverse)
library(svglite) # for exporting graphics as svg

popmap <- read_table("popmap_camilla.txt", col_names = c("sample", "population"))
popmap <- read_table("popmap_paphia_coordinates.txt", col_names = c("sample", "population", "latitude", "longitude"))

# Initialize an empty tibble to store all data
all_data <- tibble(sample = character(),
                   k = numeric(),
                   Q = character(),
                   value = numeric())

# Loop through the K values and read data
for (k in 2:5) {
  # Read the Q file for the current K value
  data <- read_delim(paste0("paphia_vcf.", k, ".Q"),
                     col_names = paste0("Q", seq(1:k)),
                     delim = " ")
  
  # Add sample names and K value to the data
  data$sample <- popmap$sample
  data$k <- k
  
  # Convert from wide to long format
  data <- data %>%
    pivot_longer(cols = starts_with("Q"), names_to = "Q", values_to = "value")
  
  # Append to the all_data tibble
  all_data <- bind_rows(all_data, data)
}

print(all_data)
all_data

#plot the panel for a selected K
plot <- all_data %>%
  filter(k == 3) %>%
  ggplot(aes(x = sample, y = value, fill = factor(Q))) + 
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "ADMIXTURE Analysis for K=3", x = "Sample", y = "Ancestry Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

print (plot)
ggsave("admixture_plot_K3.pdf", plot = plot, width = 10, height = 8)


# Create a multi-panel plot for all K values
plot <- ggplot(all_data, aes(x = sample, y = value, fill = factor(Q))) + 
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ k, ncol = 1, scales = "free_x") +
  labs(title = "ADMIXTURE Analysis", x = "Sample", y = "Ancestry Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        strip.text = element_text(size = 12),
        panel.spacing = unit(1, "lines"))
print(plot)

ggsave("admixture_plot_combined.pdf", plot = plot, width = 12, height = 20)
ggsave("admixture_plot_combined.tiff", plot = plot, width = 12, height = 10, dpi = 300)
ggsave("admixture_plot_combined.svg", plot = plot, width = 12, height = 10)

##################################################################################################
##################################################################################################
#### THIS ORDERS THE SAMPLES IN THE GRAPH ACCORDING TO SECOND COLUMN - NAME OF THE POPULATION
##################################################################################################

# Read population information
#popmap <- read_table("popmap_paphia_coordinates.txt", col_names = c("sample", "population", "latitude", "longitude"))

# Initialize an empty tibble to store all data
all_data <- tibble(sample = character(),
                   population = character(),
                   k = numeric(),
                   Q = character(),
                   value = numeric())

# Loop through the K values and read data
for (k in 2:5) {
  # Read the Q file for the current K value
  data <- read_delim(paste0("camilla_vcf.", k, ".Q"),
                     col_names = paste0("Q", seq(1:k)),
                     delim = " ")
  
  # Add sample names and K value to the data
  data$sample <- popmap$sample
  data$k <- k
  
  # Convert from wide to long format
  data <- data %>%
    pivot_longer(cols = starts_with("Q"), names_to = "Q", values_to = "value") %>%
    left_join(popmap, by = "sample")
  
  # Append to the all_data tibble
  all_data <- bind_rows(all_data, data)
}

# Ensure that sample ordering is correctly set by population
all_data <- all_data %>%
  mutate(sample = factor(sample, levels = unique(popmap$sample[order(popmap$population)])))

# Create a multi-panel plot for all K values, with samples ordered by population
plot <- ggplot(all_data, aes(x = sample, y = value, fill = factor(Q))) + 
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ k, ncol = 1, scales = "free_x") +
  labs(title = "ADMIXTURE Analysis", x = "Sample", y = "Ancestry Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        strip.text = element_text(size = 12),
        panel.spacing = unit(1, "lines"))

#when we want to put names of populations instead of samples:
plot <- ggplot(all_data, aes(x = sample, y = value, fill = factor(Q))) + 
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ k, ncol = 1, scales = "free_x") +
  scale_x_discrete(labels = popmap$population[match(levels(all_data$sample), popmap$sample)]) +
  labs(title = "ADMIXTURE Analysis", x = "Population", y = "Ancestry Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        strip.text = element_text(size = 12),
        panel.spacing = unit(1, "lines"))



# Display the plot
print(plot)

# Save
ggsave("admixture_plot_camilla_indiv.pdf", plot = plot, width = 12, height = 20)
ggsave("admixture_plot_combined.tiff", plot = plot, width = 12, height = 10, dpi = 300)
ggsave("admixture_plot_combined.svg", plot = plot, width = 12, height = 10)


##################################################################################
############################ customized order of populations#####################
##################################################################################

library(tidyverse)

# Read population information
#popmap <- read_table("popmap_camilla_filtr.txt", col_names = c("sample", "population"))
popmap <- read_table("popmap_paphia.txt", col_names = c("sample", "population"))

# Define the desired order of populations
#paphia
desired_population_order <- c("Algeria", "Kyrgyzstan", "Kazakhstan", "Japan_Hokk", "Japan_Hon", "China_South", "China", "FarEast", "Armenia", "Georgia", "Dagestan", "Ural", "Ukraine", "Poland","Hungary", "Romania", "Slovenia", "Czechia", "Czechia_M",  "Sweden", "England", "France",  "Spain_central", "Spain_north",  "Sardinia", "Corsica", "Italy_central", "Italy_south", "Sicily") # Replace with your desired order


# Set population column as a factor with the desired order
popmap$population <- factor(popmap$population, levels = desired_population_order)


# Initialize an empty tibble to store all data
all_data <- tibble(sample = character(),
                   population = character(),
                   k = numeric(),
                   Q = character(),
                   value = numeric())

# Loop through the K values and read data
for (k in 2:7) {
  # Read the Q file for the current K value
  data <- read_delim(paste0("paphia_vcf.", k, ".Q"),
                     col_names = paste0("Q", seq(1:k)),
                     delim = " ")
  
  # Add sample names and K value to the data
  data$sample <- popmap$sample
  data$k <- k
  
  # Convert from wide to long format
  data <- data %>%
    pivot_longer(cols = starts_with("Q"), names_to = "Q", values_to = "value") %>%
    left_join(popmap, by = "sample")
  
  # Append to the all_data tibble
  all_data <- bind_rows(all_data, data)
}

# Ensure that sample ordering is correctly set by the desired population order
all_data <- all_data %>%
  mutate(sample = factor(sample, levels = unique(popmap$sample[order(popmap$population)])))


# Create a multi-panel plot for all K values, with samples ordered by population
plot <- ggplot(all_data, aes(x = sample, y = value, fill = factor(Q))) + 
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ k, ncol = 1, scales = "free_x") +
  labs(title = "ADMIXTURE Analysis", x = "Sample", y = "Ancestry Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        strip.text = element_text(size = 12),
        panel.spacing = unit(1, "lines"))

#when we want to put names of populations instead of samples:
plot <- ggplot(all_data, aes(x = sample, y = value, fill = factor(Q))) + 
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ k, ncol = 1, scales = "free_x") +
  scale_x_discrete(labels = popmap$population[match(levels(all_data$sample), popmap$sample)]) +
  labs(title = "ADMIXTURE Analysis", x = "Population", y = "Ancestry Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        strip.text = element_text(size = 12),
        panel.spacing = unit(1, "lines"))

# Display the plot
print(plot)

# Save
ggsave("admixture_plot_combined_pops.pdf", plot = plot, width = 12, height = 20)
ggsave("admixture_plot_combined.tiff", plot = plot, width = 12, height = 10, dpi = 300)
ggsave("admixture_plot_rivularis.svg", plot = plot, width = 12, height = 10)


########################################################################################
###############if we want to change the colors, but it does not assign them to special cluster
##############################################################################################

library(tidyverse)

# Read population information
#popmap <- read_tsv("popmap_camilla_filtr.txt", col_names = c("sample", "population"))
popmap <- read_table("popmap_paphia_coordinates.txt", col_names = c("sample", "population", "latitude", "longitude"))

# Define the desired order of populations
#paphia
desired_population_order <- c("Algeria", "Kyrgyzstan", "Kazakhstan", "Japan_Hokk", "Japan_Hon", "China_South", "China", "FarEast", "Armenia", "Georgia", "Dagestan", "Ural", "Ukraine", "Poland","Hungary", "Romania", "Slovenia", "Czechia", "Czechia_M",  "Sweden", "England", "France",  "Spain_central", "Spain_north",  "Sardinia", "Corsica", "Italy_central", "Italy_south", "Sicily") # Replace with your desired order

# Set population column as a factor with the desired order
popmap$population <- factor(popmap$population, levels = desired_population_order)

# Initialize an empty tibble to store all data
all_data <- tibble(sample = character(),
                   population = character(),
                   k = numeric(),
                   Q = character(),
                   value = numeric())

# Loop through the K values and read data
for (k in 2:7) {
  # Read the Q file for the current K value
  data <- read_delim(paste0("paphia_vcf.", k, ".Q"),
                     col_names = paste0("Q", seq(1:k)),
                     delim = " ")
  
  # Add sample names and K value to the data
  data$sample <- popmap$sample
  data$k <- k
  
  # Convert from wide to long format
  data <- data %>%
    pivot_longer(cols = starts_with("Q"), names_to = "Q", values_to = "value") %>%
    left_join(popmap, by = "sample")
  
  # Append to the all_data tibble
  all_data <- bind_rows(all_data, data)
}

# Ensure that sample ordering is correctly set by the desired population order
all_data <- all_data %>%
  mutate(sample = factor(sample, levels = unique(popmap$sample[order(popmap$population)])))

# Define custom colors for the clusters (you can customize this palette)
custom_colors <- c("#e41a1c", "#377eb8", "#d9d9d9", "#ffd700","#33a02c","#b2df8a", "#fccde5", "purple", "orange", "cyan", "pink", "yellow", "brown", "gray", "lime", "teal", "indigo", "violet")


# Create a multi-panel plot for all K values, with samples ordered by population
plot <- ggplot(all_data, aes(x = sample, y = value, fill = factor(Q))) + 
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ k, ncol = 1, scales = "free_x") +
  scale_fill_manual(values = custom_colors) +  # Apply custom colors
  labs(title = "ADMIXTURE Analysis", x = "Sample", y = "Ancestry Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        strip.text = element_text(size = 12),
        panel.spacing = unit(1, "lines"))

#when we want to put names of populations instead of samples:
plot <- ggplot(all_data, aes(x = sample, y = value, fill = factor(Q))) + 
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ k, ncol = 1, scales = "free_x") +
  scale_x_discrete(labels = popmap$population[match(levels(all_data$sample), popmap$sample)]) +
  scale_fill_manual(values = custom_colors) +  # Apply custom colors
  labs(title = "ADMIXTURE Analysis", x = "Population", y = "Ancestry Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        strip.text = element_text(size = 12),
        panel.spacing = unit(1, "lines"))

# Display the plot
print(plot)

# Save
ggsave("admixture_paphia_barplots.pdf", plot = plot, width = 12, height = 20)
ggsave("admixture_plot_combined.tiff", plot = plot, width = 12, height = 10, dpi = 300)
ggsave("admixture_plot_rivularis.svg", plot = plot, width = 12, height = 10)


#################################################################################################
#################################################################################################
##################PLOTTING ON THE MAP ###########################################################
#################################################################################################
#################################################################################################

# Libraries
library(tidyverse)
library(ggplot2)
library(sf)
library(scatterpie)
library(rnaturalearth) # For world map data
library(rnaturalearthdata) # Additional map data
library(patchwork) # For combining plots
library(RColorBrewer) # For color palettes

# Read population information (assuming latitude and longitude are available)
popmap <- read_table("popmap_paphia_coordinates.txt", col_names = c("sample", "population", "latitude", "longitude"))

# Define the K values you want to analyze
k_values <- 2:7

# Get the world map data
world_map <- map_data("world")

# Initialize an empty list to store the maps
map_plots <- list()

# Loop through the K values to create maps for each K
for (k in k_values) {
  # Read Q file for the current K value
  data <- read_delim(paste0("paphia_vcf.", k, ".Q"),
                     col_names = paste0("Q", seq(1:k)),
                     delim = " ")
  
  # Add sample names and K value
  data$sample <- popmap$sample
  data$k <- k
  
  # Convert from wide to long format and add population data
  data <- data %>%
    pivot_longer(cols = starts_with("Q"), names_to = "Q", values_to = "value") %>%
    left_join(popmap, by = "sample")
  
  # Aggregate data for each location and average values for pie charts
  pie_data <- data %>%
    group_by(latitude, longitude, Q) %>%
    summarize(mean_value = mean(value), .groups = 'drop') %>%
    pivot_wider(names_from = Q, values_from = mean_value)
  
  # Create the map plot with the scatterpie layer
  map_plot <- ggplot() +
    
    # Add the world map as the background
    geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
                 fill = "lightgray", color = "white") +
    
    # Add pie charts at each location (with black borders)
    geom_scatterpie(data = pie_data, aes(x = longitude, y = latitude),
                    cols = paste0("Q", 1:k),
                    color = "black",    # Black margin for pies
                    pie_scale = 0.6) +  # Adjust pie scale for proper sizing
    
    # Use RColorBrewer palette for better color control
    scale_fill_brewer(palette = "Set1") +
    
    # Set limits for the Palearctic region
    coord_fixed(xlim = c(-10, 180), ylim = c(25, 70)) +
    
    # Remove unnecessary elements like axis text and titles
    theme_minimal() +
    theme(legend.position = "none",        # No legend
          axis.text = element_blank(),     # No axis labels
          axis.ticks = element_blank(),    # No axis ticks
          axis.title = element_blank(),    # No axis titles
          panel.grid = element_blank(),    # Remove grid lines
          strip.text = element_blank(),    # No strip text for facets
          panel.spacing = unit(0, "lines")) # No extra spacing
  
  # Store each plot into the list
  map_plots[[k - 1]] <- map_plot
}

# Combine all maps into a single figure (1 column, 4 rows)
combined_plot <- wrap_plots(map_plots, ncol = 1)

# Save the combined plot as SVG and PDF
ggsave("admix_combined_map_circular_pies_fixed.svg", plot = combined_plot, width = 10, height = 20, units = "in", dpi = 300)
ggsave("admix_combined_map_circular_pies_fixed.pdf", plot = combined_plot, width = 10, height = 20, units = "in")

# Display the plot
print(combined_plot)

#########################################################################
#########################zoom to Europe##################################


# Define the map limits for Europe
europe_bounds <- list(xlim = c(-10, 33), ylim = c(25, 70))

# Loop through the K values to create maps for each K
for (k in k_values) {
  # Read Q file for the current K value
  data <- read_delim(paste0("paphia_vcf.", k, ".Q"),
                     col_names = paste0("Q", seq(1:k)),
                     delim = " ")
  
  # Add sample names and K value
  data$sample <- popmap$sample
  data$k <- k
  
  # Convert from wide to long format and add population data
  data <- data %>%
    pivot_longer(cols = starts_with("Q"), names_to = "Q", values_to = "value") %>%
    left_join(popmap, by = "sample")
  
  # Aggregate data for each location and average values for pie charts
  pie_data <- data %>%
    group_by(latitude, longitude, Q) %>%
    summarize(mean_value = mean(value), .groups = 'drop') %>%
    pivot_wider(names_from = Q, values_from = mean_value)
  
  # Create the map plot with the scatterpie layer
  map_plot <- ggplot() +
    
    # Add the world map as the background
    geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
                 fill = "lightgray", color = "white") +
    
    # Add pie charts at each location (with black borders)
    geom_scatterpie(data = pie_data, aes(x = longitude, y = latitude),
                    cols = paste0("Q", 1:k),
                    color = "black",    # Black margin for pies
                    pie_scale = 0.3) +  # Adjust pie scale for proper sizing
    
    # Use RColorBrewer palette for better color control
    scale_fill_brewer(palette = "Set1") +
    
    # Set limits for Europe
    coord_fixed(xlim = europe_bounds$xlim, ylim = europe_bounds$ylim) +
    
    # Remove unnecessary elements like axis text and titles
    theme_minimal() +
    theme(legend.position = "none",        # No legend
          axis.text = element_blank(),     # No axis labels
          axis.ticks = element_blank(),    # No axis ticks
          axis.title = element_blank(),    # No axis titles
          panel.grid = element_blank(),    # Remove grid lines
          strip.text = element_blank(),    # No strip text for facets
          panel.spacing = unit(0, "lines")) # No extra spacing
  
  # Store each plot into the list
  map_plots[[k - 1]] <- map_plot
}

# Combine all maps into a single figure (1 column, 4 rows)
combined_plot <- wrap_plots(map_plots, ncol = 1)

# Save the combined plot as SVG and PDF
ggsave("admix_combined_map_europe.svg", plot = combined_plot, width = 10, height = 20, units = "in", dpi = 300)
ggsave("admix_combined_map_europe.pdf", plot = combined_plot, width = 10, height = 20, units = "in", dpi = 300)

# Display the plot
print(combined_plot)


###################################################################
######################only a selected K############################

# Load necessary libraries
library(tidyverse)
library(ggplot2)
library(sf)
library(scatterpie)
library(maps)
library(patchwork)
library(RColorBrewer)

# Read population information (assuming latitude and longitude are available)
popmap <- read_tsv("popmap_camilla_coord.txt", col_names = c("sample", "population", "latitude", "longitude"))

# Define the European map bounds for zooming in
europe_bounds <- list(xlim = c(10, 33), ylim = c(35, 60))
europe_bounds <- list(xlim = c(125, 135), ylim = c(38, 50))

# Read Q file for K = 5
k <- 5
data <- read_delim(paste0("camilla_vcf.", k, ".Q"),
                   col_names = paste0("Q", seq(1:k)),
                   delim = " ")

# Add sample names and K value
data$sample <- popmap$sample
data$k <- k

# Convert from wide to long format and add population data
data <- data %>%
  pivot_longer(cols = starts_with("Q"), names_to = "Q", values_to = "value") %>%
  left_join(popmap, by = "sample")

# Aggregate data for each location and average values for pie charts
pie_data <- data %>%
  group_by(latitude, longitude, Q) %>%
  summarize(mean_value = mean(value), .groups = 'drop') %>%
  pivot_wider(names_from = Q, values_from = mean_value)

# Get the world map data
world_map <- map_data("world")

# Create the map plot with the scatterpie layer
map_plot <- ggplot() +
  
  # Add the world map as the background
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "lightgray", color = "white") +
  
  # Add pie charts at each location (with black borders)
  geom_scatterpie(data = pie_data, aes(x = longitude, y = latitude),
                  cols = paste0("Q", 1:k),
                  color = "black",    # Black margin for pies
                  pie_scale = 0.1) +  # Adjust pie scale for proper sizing
  
  # Use RColorBrewer palette for better color control
  scale_fill_brewer(palette = "Set1") +
  
  # Set limits for the specified European region
  coord_fixed(xlim = europe_bounds$xlim, ylim = europe_bounds$ylim) +
  
  # Remove unnecessary elements like axis text and titles
  theme_minimal() +
  theme(legend.position = "none",        # No legend
        axis.text = element_blank(),     # No axis labels
        axis.ticks = element_blank(),    # No axis ticks
        axis.title = element_blank(),    # No axis titles
        panel.grid = element_blank(),    # Remove grid lines
        strip.text = element_blank(),    # No strip text for facets
        panel.spacing = unit(0, "lines")) # No extra spacing

# Save the map as SVG and PDF
ggsave("admix_map_europe_K5.svg", plot = map_plot, width = 10, height = 10, units = "in", dpi = 300)
ggsave("admix_map_europe_K5.pdf", plot = map_plot, width = 10, height = 10, units = "in")

# Display the map plot
print(map_plot)


#################################################################################
##################################################################################
##### somewhat allows to create the customized map according to prevailing cluster
###### but not perfect############################################################

# Set region-color mapping
region_colors <- c(
  "Japan_Hon" = "#b2df8a",        
  "Spain_north" = "#377eb8", 
  "Dagestan" = "#d9d9d9",    
  "Czechia" = "#ffd700",     
  "Sicily" = "#33a02c",      
  "Kyrgyzstan" = "#e41a1c",  
  "Algeria" = "#fccde5"     
)

# Read population metadata
popmap <- read_table("popmap_paphia_coordinates.txt", col_names = c("sample", "population", "latitude", "longitude"))

# Define K values
k_values <- 2:7

# Load world map
world_map <- map_data("world")

# Function to get cluster to color mapping
get_cluster_color_mapping <- function(admix_data, popmap, k) {
  data <- admix_data
  data$sample <- popmap$sample
  data <- data %>%
    pivot_longer(cols = starts_with("Q"), names_to = "cluster", values_to = "value") %>%
    left_join(popmap, by = "sample")
  
  # Filter only the populations we care about
  target_pops <- names(region_colors)
  data <- data %>% filter(population %in% target_pops)
  
  # For each target population, find the cluster with max average in that population
  dominant_clusters <- data %>%
    group_by(population, cluster) %>%
    summarize(avg_prop = mean(value), .groups = "drop") %>%
    group_by(population) %>%
    slice_max(order_by = avg_prop, n = 1, with_ties = FALSE)
  
  # Assign colors to clusters based on which population they are dominant in
  cluster_color <- rep("grey", k)
  names(cluster_color) <- paste0("Q", 1:k)
  
  for (i in 1:nrow(dominant_clusters)) {
    cluster <- dominant_clusters$cluster[i]
    pop <- dominant_clusters$population[i]
    cluster_color[cluster] <- region_colors[pop]
  }
  
  return(cluster_color)
}

# Function to generate plot for a single K
make_admixture_plot <- function(k, coord_limits = c(-10, 180, 25, 70), pie_scale = 0.6) {
  qfile <- paste0("paphia_vcf.", k, ".Q")
  admix <- read_delim(qfile, col_names = paste0("Q", 1:k), delim = " ")
  admix$sample <- popmap$sample
  admix$k <- k
  
  cluster_colors <- get_cluster_color_mapping(admix, popmap, k)
  
  long_data <- admix %>%
    pivot_longer(cols = starts_with("Q"), names_to = "cluster", values_to = "value") %>%
    left_join(popmap, by = "sample")
  
  pie_data <- long_data %>%
    group_by(latitude, longitude, cluster) %>%
    summarize(mean_value = mean(value), .groups = 'drop') %>%
    pivot_wider(names_from = cluster, values_from = mean_value)
  
  ggplot() +
    geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
                 fill = "lightgray", color = "white") +
    geom_scatterpie(data = pie_data, aes(x = longitude, y = latitude),
                    cols = paste0("Q", 1:k),
                    color = "black",
                    pie_scale = pie_scale) +
    scale_fill_manual(values = cluster_colors) +
    coord_fixed(xlim = coord_limits[1:2], ylim = coord_limits[3:4]) +
    theme_minimal() +
    theme(
      legend.position = "none",
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      panel.grid = element_blank(),
      strip.text = element_blank(),
      panel.spacing = unit(0, "lines")
    )
}

# Generate and save combined plots
map_plots <- lapply(k_values, function(k) make_admixture_plot(k))
combined_plot <- wrap_plots(map_plots, ncol = 1)

ggsave("admixture_paphia_map.pdf", plot = combined_plot, width = 10, height = 18)

